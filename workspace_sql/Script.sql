SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION ALL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10;

SELECT * FROM EMP WHERE DEPTNO =10 OR DEPTNO =20;

SELECT * FROM EMP 
WHERE DEPTNO IN (10,20);

SELECT * FROM EMP
WHERE DEPTNO NOT IN (10,20);

SELECT * FROM EMP
WHERE SAL BETWEEN 2000 AND 3000;

SELECT * FROM EMP
WHERE SAL >=2000 AND SAL <= 3000;

--p130. Q1
SELECT * FROM EMP
WHERE ENAME LIKE '%S';

--Q2
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO = 30
AND JOB = 'SALESMAN';

--Q3
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO IN (20,30)
AND SAL >2000;

--Q3
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO IN (20,30)
MINUS
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE
SAL <= 2000;

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO = 20 AND SAL> 2000
UNION 
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO = 30 AND SAL> 2000;

--Q4
SELECT * FROM EMP
WHERE SAL < 2000 OR SAL > 3000;

SELECT * FROM EMP
WHERE NOT (SAL >= 2000 AND SAL <=3000);

SELECT * FROM EMP
WHERE SAL NOT BETWEEN 2000 AND 3000;

--Q5
SELECT ENAME, EMPNO, SAL, DEPTNO FROM EMP
WHERE ENAME LIKE '%E%' 
AND DEPTNO = 30 
AND SAL <=1000
UNION 
SELECT ENAME, EMPNO, SAL, DEPTNO FROM EMP
WHERE ENAME LIKE '%E%' 
AND DEPTNO = 30 
AND SAL >=2000;

SELECT ENAME, EMPNO, SAL, DEPTNO FROM EMP
WHERE ENAME LIKE '%E%' 
AND DEPTNO = 30 
AND SAL NOT BETWEEN 1000 AND 2000;

--Q6
SELECT * FROM EMP
WHERE COMM IS NULL 
AND MGR IS NOT NULL 
AND JOB IN ('MANAGER','CLERK')
AND ENAME NOT LIKE '_L%';

SELECT * FROM EMP
WHERE DEPTNO IN (20,30)
AND SAL BETWEEN 2000 AND 3000
ORDER BY SAL, ENAME;

SELECT * FROM EMP
WHERE ENAME LIKE '__A%';

SELECT ENAME AS EMPLOYEE_NAME, DEPTNO AS DEPARTMENT_NO  FROM EMP
ORDER BY DEPTNO, ENAME;

---함수
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME)
FROM EMP;

SELECT LOWER(ENAME, JOB)
FROM EMP;
--에러

SELECT 1
FROM DUAL;
--DUAL은 한 칸 짜리 임시 테이블
SELECT UPPER('aBc'), LOWER('aBc') FROM DUAL;

SELECT * FROM EMP
WHERE ENAME LIKE '%AM%';

SELECT * FROM EMP
WHERE LOWER(ENAME) LIKE LOWER('%AM%');

SELECT ENAME, LENGTH(ENAME)
FROM EMP;

SELECT ENAME, LENGTH(ENAME)
FROM EMP 
WHERE LENGTH(ENAME) >= 5;

SELECT LENGTH('한글'), LENGTHB('한글')
FROM DUAL;

--25.12.16---------------------------

SELECT *
FROM emp
WHERE lower(ename) LIKE lower('%a%e%');

SELECT JOB, SUBSTR(JOB,1,20), SUBSTR(JOB,3,2), SUBSTR(JOB,5)
FROM EMP;

SELECT SUBSTR(ENAME,3)
FROM EMP;
--시작 위치가 범위를 넘어가면 NULL, 추출갯수는 많아도 상관 없음

SELECT 'A-B-C' AS REPLACE_BEFORE,
replace('A-B-C','-',' ') AS REPLACE_1,
REPLACE('A-B-C', '-') AS REPLACE_2
FROM DUAL;

SELECT ENAME, REPLACE(ename, 'A', 'abc')
FROM EMP;

SELECT ENAME, REPLACE(ENAME, 'A', 'abc')
FROM EMP
WHERE ENAME LIKE '%A%';

SELECT LPAD(ENAME, 10, '#'), LPAD(ENAME,5,'#')	
FROM EMP;

SELECT RPAD(ENAME, 10, '123456789AB')
FROM EMP;
--PAD는 자릿수 넘어가는 데이터는 짤림, 채울 문자는 자릿수 넘어도 상관없음

--DISCORD Q1
SELECT ENAME, SUBSTR(ENAME,1,2)
FROM EMP;

SELECT ENAME, RPAD(ENAME,2)
FROM EMP;

SELECT ENAME, REPLACE(ENAME,SUBSTR(ENAME,3))
FROM EMP;

--Q2
SELECT ENAME, RPAD(SUBSTR(ENAME,1,2),6,'*')
FROM EMP;

--Q3
SELECT ENAME, RPAD(SUBSTR(ENAME,1,2), LENGTH(ENAME),'*')
FROM EMP;

SELECT EMPNO, ENAME, CONCAT(EMPNO, ENAME), CONCAT(EMPNO,CONCAT(':',ENAME))
FROM EMP 
WHERE ENAME='SCOTT';

SELECT EMPNO || ENAME, EMPNO || ':' || ENAME
FROM EMP;

SELECT 'AB' || 'CD' 
FROM DUAL;

--Q4
SELECT ENAME, '**' || SUBSTR(ENAME,3)
FROM EMP;

SELECT ENAME, LPAD(SUBSTR(ENAME,3), LENGTH(ENAME), '*')
FROM EMP;

SELECT '[' || '  _  _ORACLE_  _  ' || ']',
'[' || TRIM('  _  _ORACLE_  _  ') || ']'
FROM DUAL;

--숫자함수
SELECT ROUND(14.46), ROUND(14.46,1), ROUND(14.46, -1), ROUND(-14.46,1)
FROM DUAL;

SELECT TRUNC(14.46), TRUNC(14.46, 1), TRUNC(14.46, -1), TRUNC(-14.46)
FROM DUAL;

SELECT CEIL(3.14), FLOOR(3.14), CEIL(-3.14), FLOOR(-3.14), TRUNC(-3.14)
FROM DUAL;
--ROUND 반올림 TRUNC 버림 CEIL 지정된 숫자에서 가장 가깝고 큰 정수 FLOOR 지정된 숫자에서 가장 가깝고 작은 정수
--CEIL/FLOOR를 사용할때는 하나의 프로그램에서 하나만 사용하자
--프로그램을 혼용하거나 CEIL/FLOOR 혼용시 계산 값이 틀려질 수 있다

SELECT MOD(15,6), MOD(15,0)
FROM DUAL;
--일반적으로 0으로 나누려 하면 에러 뜨는데 MOD는 분모가 분자보다 작아질때까지 빼고 남은 숫자를 보여주는거라 0으로 나누면 분모가 그대로 나옴

SELECT MOD(6,3), MOD(7,3), MOD(8,3), MOD(9,3)
FROM DUAL;

SELECT SYSDATE 
FROM DUAL;

SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE,120)
FROM EMP;
--ADD_YEARS 안됨

--TO_CHAR "형식을 지정"해서 문자로 바꿈)
SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS')
FROM DUAL;

SELECT TO_CHAR(HIREDATE,'YY/MM/DD')
FROM EMP;

SELECT TO_CHAR(SYSDATE, 'YYYY"년" MM"월" DD"일" HH24"시" MI"분" SS"초"')
FROM DUAL;
--한글은 쌍따옴표로 감싸야 에러 안 남 

SELECT *
FROM EMP
WHERE HIREDATE > TO_DATE('1981/06/01', 'YYYY/MM/DD')
ORDER BY HIREDATE;

--NULL 처리함수
SELECT SAL,COMM,SAL+COMM, 
NVL(COMM,0), SAL+NVL(COMM,0), NVL(TO_CHAR(COMM), 'N/A')
FROM EMP;

SELECT COMM, NVL2(COMM,'O', 'X')
FROM EMP;

--DECODE는 IF랑 비슷
SELECT ENAME,JOB, SAL,
	DECODE(JOB,
		'MAMAGER', SAL*1.1,
		'SALESMAN', SAL*1.05,
		'ANALYST' , SAL, 
		SAL*1.03)
FROM EMP;

SELECT JOB, SAL,
	CASE JOB
		WHEN 'MANAGER' THEN SAL*1.1
		WHEN 'SALESMAN' THEN SAL*1.05
		WHEN 'ANALYST' THEN SAL 
		ELSE SAL*1.03
	END 
FROM EMP;
---CASE로 시작하면 END로 닫아야 함/ WHEN THEN은 페어

SELECT COMM,
	CASE
		WHEN COMM IS NULL THEN '해당 사항 없음'
		WHEN COMM = 0 THEN '수당 없음'
		WHEN COMM > 0 THEN '수당 : ' || COMM
	END
FROM EMP;
--DECODE는 EQUAL 만 조건으로 걸수 있음

--P.179 Q1
SELECT 
	EMPNO, 
	LPAD(EMPNO,2) || '**' AS MASKING_EMPNO,  ENAME, 
	RPAD(SUBSTR(ENAME,1,1), LENGTH(ENAME), '*') AS MASKING_ENAME
FROM EMP
WHERE LENGTH(ENAME) = 5;


--Q2
SELECT 
	TO_CHAR(EMPNO,'9999') AS EMPNO,
	ENAME, 
	TO_CHAR(SAL,'9999') AS SAL,
	TRUNC (SAL/21.5,2) AS DAY_PAY,
	ROUND (SAL/(21.5*8),1) AS TIME_PAY
FROM EMP;

--Q3
SELECT
	TO_CHAR(EMPNO, '9999') AS EMPNO, 
	ENAME, 
	TO_CHAR(HIREDATE, 'YY/MM/DD') AS HIREDATE,
	TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE,3), '월요일'), 'YYYY-MM-DD') AS R_JOB,
	CASE 
		WHEN COMM IS NULL THEN 'N/A'
		ELSE TO_CHAR(COMM)
	END AS COMM
FROM EMP; 

--Q4
SELECT
	TO_CHAR(EMPNO) AS EMPNO,
	ENAME, 
	TO_CHAR(MGR) AS MGR,
	CASE 
		WHEN MGR IS NULL THEN '0000'
		WHEN LPAD(MGR,2) = 75 THEN '5555'
		WHEN LPAD(MGR,2) = 76 THEN '6666'
		WHEN LPAD(MGR,2) = 77 THEN '7777'
		WHEN LPAD(MGR,2) = 78 THEN '8888'
		ELSE TO_CHAR(MGR)
	END	AS CHG_MGR
FROM EMP;

SELECT
	TO_CHAR(EMPNO, '9999') AS EMPNO,
	ENAME, 
	TO_CHAR(MGR, '9999') AS MGR,
	CASE 
		WHEN MGR IS NULL THEN '0000'
		WHEN MGR>= 7500 AND MGR < 7600 THEN '5555'
		WHEN MGR>= 7600 AND MGR < 7700 THEN '6666'
		WHEN MGR>= 7700 AND MGR < 7800 THEN '7777'
		WHEN MGR>= 7800 AND MGR < 7900 THEN '8888'
		ELSE TO_CHAR(MGR)
	END	AS CHG_MGR
FROM EMP;
--7800 <= MGR <7900 -ERROR

SELECT
	TO_CHAR(EMPNO, '9999') AS EMPNO,
	ENAME, 
	TO_CHAR(MGR, '9999') ,
	CASE MGR
		WHEN  IS NULL THEN '0000'
		WHEN >= 7500 AND  < 7600 THEN '5555'
		WHEN >= 7600 AND  < 7700 THEN '6666'
		WHEN >= 7700 AND  < 7800 THEN '7777'
		WHEN >= 7800 AND  < 7900 THEN '8888'
		ELSE MGR
	END	AS CHG_MGR
FROM EMP;
--이거 안됨 CASE에서 앞으로 빼려면 DECODE처럼 같다 로만 조건 걸어야 하는듯?

